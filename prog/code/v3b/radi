        public static Dictionary<string, int> racines(Dictionary<string, int> init){
            string path = "../../static/hintsfiles/step1.txt";
            Dictionary<string, int> res = new Dictionary<string, int>();
            bool test;
            Dictionary<string, string> terminaison = new Dictionary<string, string>();
            if(File.Exists(path)){
                // Compare the size of the radical compared to the word we are looking at
                //Open the connection to the file
                StreamReader sr = new StreamReader(path);
                string line;
                string endOfWord;
                string replacement;
                while((line = sr.ReadLine())!= null){
                    endOfWord = line.Split(' ')[1];
                    replacement = line.Split(' ')[2];
                    if(!terminaison.ContainsKey(endOfWord)){
                        terminaison.Add(endOfWord, replacement);
                    }
                }
                foreach(KeyValuePair<string, int> kvp in init){
                    //Delete de s at the end of the word if there is one
                    test = false; 
                    string winit = kvp.Key;
                    if(winit.Length >0){
                        if(winit[winit.Length-1]=='s'){
                            winit = Reverse(Reverse(winit).Substring(1));
                        }
                    }
                    
                    foreach(KeyValuePair<string, string> kvpF in terminaison.OrderBy(key => key.Key)){
                        string wout = kvpF.Key;
                        //if winit is bigger thant wout
                        if(winit.Length > wout.Length){
                            if(winit.Substring(winit.Length-wout.Length)==wout){
                                string final = Reverse(Reverse(kvp.Key).Substring(wout.Length));
                                if(kvpF.Value == "epsilon"){
                                    if(res.ContainsKey(final)){
                                        res[final] += init[kvp.Key];
                                    }
                                    else{
                                        res.Add(final, kvp.Value);
                                    }
                                    break; //Ncessaire pour quitter la boucle et ne pas rajouter plusieures fois le mot
                                }
                                else{
                                    final += kvpF.Value;
                                    if(res.ContainsKey(final)){
                                        res[final] += init[kvp.Key];
                                    }
                                    else{
                                        res.Add(final, kvp.Value);
                                    }
                                    break; //Necessaire pour quitter la boucle et ne pas rajouter plusieures fois le mot
                                }

                            }
                        }
                    }
                    
                }
                
            }
            else System.Console.WriteLine("nope");
            return res;
        }

